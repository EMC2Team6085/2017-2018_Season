package org.firstinspires.ftc.teamcode.Season17and18;

import android.app.Activity;
import android.graphics.Color;
import android.view.View;

import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.ColorSensor;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.LightSensor;
import com.qualcomm.robotcore.hardware.OpticalDistanceSensor;
import com.qualcomm.hardware.modernrobotics.ModernRoboticsI2cGyro;
import com.qualcomm.robotcore.hardware.IntegratingGyroscope;
import com.qualcomm.robotcore.util.ElapsedTime;
import com.qualcomm.robotcore.hardware.Gyroscope;

import org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;
import org.firstinspires.ftc.robotcore.external.navigation.AngularVelocity;
import org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;
import org.firstinspires.ftc.robotcore.external.navigation.AxesReference;

import org.firstinspires.ftc.robotcontroller.external.samples.ConceptVuforiaNavigation;
import org.firstinspires.ftc.robotcore.external.ClassFactory;
import org.firstinspires.ftc.robotcore.external.matrices.OpenGLMatrix;
import org.firstinspires.ftc.robotcore.external.navigation.RelicRecoveryVuMark;
import org.firstinspires.ftc.robotcore.external.navigation.VuMarkInstanceId;
import org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;
import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackable;
import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackableDefaultListener;
import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackables;

@Autonomous(name="AutoDriveBlue", group="Autonomous")

public class AutoDriveBlue extends LinearOpMode {
    double i = 0;
    double n = 0;
    private static final double servoPos2 = 0.85;
    private static final double servoPos1 = 0.3;
    private static final double STRAFE_POWER = 0.7;
    HardwareMapping robot = new HardwareMapping();
    ColorSensor colorSensor;
    VuforiaLocalizer vuforia;
    ElapsedTime timer = new ElapsedTime();

    public void runOpMode() throws InterruptedException {
        int rawX = robot.modernRoboticsI2cGyro.rawX();
        int rawY = robot.modernRoboticsI2cGyro.rawY();
        int rawZ = robot.modernRoboticsI2cGyro.rawZ();
        int heading = robot.modernRoboticsI2cGyro.getHeading();
        int integratedZ = robot.modernRoboticsI2cGyro.getIntegratedZValue();
        robot.init(hardwareMap);
        int cameraMonitorViewId = hardwareMap.appContext.getResources().getIdentifier("cameraMonitorViewId", "id", hardwareMap.appContext.getPackageName());
        VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters(cameraMonitorViewId);

        parameters.vuforiaLicenseKey = "ASxYq8z/////AAAAGfKVNNE3jU+gvP8mNaYt5P10PoBkHejK3PS1xher3fPIXyBxpFvFC/HLUBT/nThQuxl0zY6zI7EtPsk/CVOqgKa5YlyulrjYVZ/P8T/dhPyFyqml9UEBixPKcgNPSeu8xd2q1oUMvxYm33tuX/flCOtgWO2tLjgpTlMK7BM0hn2hNK8BgylLqSchG7aIdsr909swav2LqY1ZAa4qml4LoQwSkvQ1SzSSC7egkEkmWK4+U/lDnD4Wly++WqvKpP5fUWF69bW5c4/wCyww99UBlUISrMBuR8hoRZnckvqYopzE3m4oU8m2DLFjEODGxf13bfYQ0VHSvVseqLsjUkWJHp8NW7Vb79sUdb4kNqXYS7HO";

        parameters.cameraDirection = VuforiaLocalizer.CameraDirection.FRONT;
        this.vuforia = ClassFactory.createVuforiaLocalizer(parameters);

        robot.GlyphLift.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        robot.FrontRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        robot.RearLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        robot.RearRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        robot.FrontLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        robot.LeftBalance.setPosition(servoPos1);
        robot.RightBalance.setPosition(1 - servoPos1);
        telemetry.log().add("Gyro Calibrating. Do Not Move!");
        robot.modernRoboticsI2cGyro.calibrate();
        timer.reset();
        while (!isStopRequested() && robot.modernRoboticsI2cGyro.isCalibrating())  {
            telemetry.addData("calibrating", "%s", Math.round(timer.seconds())%2==0 ? "|.." : "..|");
            telemetry.update();
            sleep(50);
        }
        telemetry.log().clear(); telemetry.log().add("Gyro Calibrated. Press Start.");
        telemetry.clear(); telemetry.update();
        //GlyphLift(0,1);
        waitForStart();
        //robot.leftPaddle.setPosition(0.86);
        //sleep(1000);
        //robot.rightPaddle.setPosition(0.28);
        sleep(50);
        robot.gemServo.setPosition(0.5);
        sleep(100);
        ColorSense();
        sleep(50);
        robot.gemServo.setPosition(1);
        sleep(500);
        ReturnToStart(0, 0.3);
        VuforiaSearch();
        //DriveStraightDistance(-500, 0.5);
        //ClawGrab();
        //GlyphLift(1050, 0.3);
        //DriveStraightDistance(3000, 0.5);
        //Turn(2100, 0.5);
        //drive forward
        //GlyphLift(0,0.3);
        //ClawRelease();
    }

    void ColorSense() {

        while (i < 500) {
            Telemetry();
            float hsvValues[] = {0F, 0F, 0F};

            final float values[] = hsvValues;

            int relativeLayoutId = hardwareMap.appContext.getResources().getIdentifier("RelativeLayout", "id", hardwareMap.appContext.getPackageName());
            final View relativeLayout = ((Activity) hardwareMap.appContext).findViewById(relativeLayoutId);

            colorSensor = hardwareMap.get(ColorSensor.class, "colorSensor");


            Color.RGBToHSV(colorSensor.red() * 8, colorSensor.green() * 8, colorSensor.blue() * 8, hsvValues);
            telemetry.addData("Clear", colorSensor.alpha());
            telemetry.addData("Red  ", colorSensor.red());
            telemetry.addData("Green", colorSensor.green());
            telemetry.addData("Blue ", colorSensor.blue());
            telemetry.addData("Hue", hsvValues[0]);

            relativeLayout.post(new Runnable() {
                public void run() {
                    relativeLayout.setBackgroundColor(Color.HSVToColor(0xff, values));
                }
            });

            telemetry.update();
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            i = i + 1;
            if (colorSensor.blue() >= 1) {
                telemetry.addData("BLUE BLUE BLUE", colorSensor.blue());
                sleep(1000);
                //move the opposite way the sensor is facing
                DriveStraightDistance(150, .3);
                i = 500;
            } else if (colorSensor.red() >= 1) {
                telemetry.addData("RED RED RED", colorSensor.red());
                sleep(1000);
                //move the way the sensor is facing
                DriveStraightDistance(-150, .3);
                i = 500;
            }

        }
    }


    void DriveStraight(double power){
        robot.FrontRight.setPower(power);
        robot.FrontLeft.setPower(power);
        robot.RearRight.setPower(power);
        robot.RearLeft.setPower(power);
    }
    void StopDriving (){
        DriveStraight(0);
    }
    void DriveStraightDistance(int distance, double power){
        telemetry.addData("Driving", "Yes");
        robot.FrontRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        robot.FrontLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        robot.RearRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        robot.RearLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);

        robot.FrontRight.setTargetPosition(distance);
        robot.FrontLeft.setTargetPosition(-distance);
        robot.RearRight.setTargetPosition(distance);
        robot.RearLeft.setTargetPosition(-distance);

        robot.FrontRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        robot.FrontLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        robot.RearRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        robot.RearLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);

        DriveStraight(power);

        while(robot.FrontRight.isBusy() && robot.RearLeft.isBusy() && robot.RearRight.isBusy() && robot.FrontLeft.isBusy()){
            Telemetry();
        }

        StopDriving();
        robot.FrontRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        robot.FrontLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        robot.RearRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        robot.RearLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    }

    void Turn (){
    }

    void ReturnToStart(int distance, double power){
        telemetry.addData("Driving", "Yes");

        robot.FrontRight.setTargetPosition(distance);
        robot.FrontLeft.setTargetPosition(-distance);
        robot.RearRight.setTargetPosition(distance);
        robot.RearLeft.setTargetPosition(-distance);

        robot.FrontRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        robot.FrontLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        robot.RearRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        robot.RearLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);

        DriveStraight(power);

        while(robot.FrontRight.isBusy() && robot.RearLeft.isBusy() && robot.RearRight.isBusy() && robot.FrontLeft.isBusy()){
            Telemetry();
        }

        StopDriving();
        robot.FrontRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        robot.FrontLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        robot.RearRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        robot.RearLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    }
    void VuforiaSearch  (){
        VuforiaTrackables relicTrackables = this.vuforia.loadTrackablesFromAsset("RelicVuMark");
        VuforiaTrackable relicTemplate = relicTrackables.get(0);
        relicTemplate.setName("relicVuMarkTemplate"); // can help in debugging; otherwise not necessary

        relicTrackables.activate();
        RelicRecoveryVuMark vuMark = RelicRecoveryVuMark.from(relicTemplate);
        while (n<500)
        {
            Telemetry();
            sleep(10);
            n=n+1;
            if (vuMark != RelicRecoveryVuMark.UNKNOWN) {
                if (vuMark == RelicRecoveryVuMark.RIGHT) {
                    telemetry.addData("VuMark", "RIGHT visible", vuMark);
                    sleep(50);
                    //drive to right
                    n=500;
                } else {
                    if (vuMark == RelicRecoveryVuMark.LEFT) {
                        telemetry.addData("VuMark", "LEFT visible", vuMark);
                        sleep(50);
                        //drive to left
                        n=500;
                    } else {
                        if (vuMark == RelicRecoveryVuMark.CENTER) {
                            telemetry.addData("VuMark", "CENTER visible", vuMark);
                            sleep(50);
                            //drive to center
                            n=500;
                        } else {
                            telemetry.addData("VuMark", "NONE visible", vuMark);
                        }
                    }
                }
            }
        }
    }

    void GlyphLift (int distance, double power){

        robot.GlyphLift.setTargetPosition(distance);

        robot.GlyphLift.setMode(DcMotor.RunMode.RUN_TO_POSITION);

        robot.GlyphLift.setPower(power);

        while(robot.GlyphLift.isBusy()){
            Telemetry();
        }

        robot.GlyphLift.setPower(0);

        robot.GlyphLift.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    }

    void ClawGrab () {
        robot.rightPaddle.setPosition(0.5);
        robot.leftPaddle.setPosition(0.64);
    }

    void ClawRelease () {
        robot.rightPaddle.setPosition(0.7);
        robot.leftPaddle.setPosition(0.44);
    }

    void Telemetry () {
        telemetry.addData("FR_Power", "%.2f",robot.FrontRight.getPower());
        telemetry.addData("RR_Power", "%.2f",robot.RearRight.getPower());
        telemetry.addData("FL_Power", "%.2f",robot.FrontLeft.getPower());
        telemetry.addData("RL_Power", "%.2f",robot.RearLeft.getPower());
        telemetry.addData("Front Right Encoder Position", robot.FrontRight.getCurrentPosition());
        telemetry.addData("Rear Right Encoder Position", robot.RearRight.getCurrentPosition());
        telemetry.addData("Front Left Encoder Position", robot.FrontLeft.getCurrentPosition());
        telemetry.addData("Rear Left Encoder Position", robot.RearLeft.getCurrentPosition());
        telemetry.addData("Left Balance Position", robot.LeftBalance.getPosition());
        telemetry.addData("Right Balance Position", robot.RightBalance.getPosition());
        telemetry.addData("GlyphLift Current Position", robot.GlyphLift.getCurrentPosition());
        telemetry.addData("GlyphLift Target Position", robot.GlyphLift.getTargetPosition());
        telemetry.addData("GlyphLift Power", robot.GlyphLift.getPower());
        telemetry.addData("gemServo", robot.gemServo.getPosition());
        telemetry.update();
    }
}
